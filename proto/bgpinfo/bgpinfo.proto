syntax = "proto3";

package bgpinfo;

service bgp_info {
    rpc add_latest(values) returns (result);
    rpc get_prefix_count(empty) returns (prefix_count_response);
    rpc update_tweet_bit(timestamp) returns (result);
    rpc get_pie_subnets(empty) returns (pie_subnets_response);
    rpc get_movement_totals(movement_request) returns (movement_totals_response);
    rpc get_pie_rpki(empty) returns (roas);
}

message values {
    // Values holds the data required to update the database every five minutes.
    uint64 time = 1;
    prefix_count prefix_count = 2;
    peer_count peers = 3;
    repeated memory mem_use = 4;
    as_count as_count = 5;
    mask masks = 6;
    large_community large_community = 7;
    roas roas = 8;
}

message empty {
    // Sometimes we just need to request data. No inputs required.
}

message prefix_count_response {
    // Used to formulate a tweet every six hours with
    // the current status, plus compared to both 6 hours ago
    // and a week ago. Contains count of /24 and /48.
    uint32 active_4 = 1;
    uint32 active_6 = 2;
    uint32 sixhoursv4 = 3;
    uint32 sixhoursv6 = 4;
    uint32 weekagov4 = 5;
    uint32 weekagov6 = 6;
    uint32 slash24 = 7;
    uint32 slash48 = 8;
    uint64 time = 9;
}

message pie_subnets_response { 
    // Used to create a pie graph showing the percentage
    // that each subnet is using from the complete total.
    uint32 v4_total = 1;
    uint32 v6_total = 2;
    mask masks = 3;
    uint64 time = 4;
}

message movement_totals_response {
    // Used to create a graph showing table movement for the
    // given time period.
    repeated v4v6time values = 1;
}

message v4v6time {
    uint32 v4_values = 1;
    uint32 v6_values = 2;
    uint64 time = 3;
}

message timestamp {
    uint64 time = 1;
}

message result {
    // Bool stating whether the update was a success or not.
    // Ragerdless of result, we can check that via the returned result.
    bool success = 1;
    string result = 2;
}

message as_count {
    // as_count will hold the total amount of unique ASs.
    // Total number of unique IPv4 source AS numbers.
    uint32 as4 = 1;
    // Total number of unique IPv6 source AS numbers.
    uint32 as6 = 2;
    // Total unique source AS numbers
    uint32 as10 = 3;
    // IPv4-only source AS.
    uint32 as4_only = 4;
    // IPv6-only source AS.
    uint32 as6_only = 5;
    // Unique AS originating both IPv4 and IPv6
    uint32 as_both = 6;
}

message movement_request {
    // graph requests determined by what time period
    // I am graphing for.
    enum TimePeriod {
        WEEK = 0;
        MONTH = 1;
        SIXMONTH = 2;
        ANNUAL = 3;
    }
    TimePeriod period = 1;
}

message memory {
    // total memory used by the daemon
    address_family family = 1;
    memstats memstats = 2;
}

message memstats {
    string tables = 1;
    string total = 2;
    string protocols = 3;
    string attributes = 4;
    string roa = 5;
}

message peer_count {
    // how many peers do I have
    uint32 peer_count_4 = 1;
    uint32 peer_up_4 = 2;
    uint32 peer_count_6 = 3;
    uint32 peer_up_6 = 4;
}

enum address_family {
    IPV6 = 0;
    IPV4 = 1;
}

message prefix_count {
    // prefix counts. Most used info
    uint32 total_4 = 1;
    uint32 active_4 = 2;
    uint32 total_6 = 3;
    uint32 active_6 = 4;
    uint64 time = 5;
}

message mask {
    repeated maskcount ipv4 = 1;
    repeated maskcount ipv6 = 2;
}

message maskcount {
    uint32 mask = 1;
    uint32 count = 2;
}

message response {
    bool status = 1;
    uint32 priority = 2;
}

message large_community {
    // Large Community count (RFC 8092)
    uint32 c4 = 1;
    uint32 c6 = 2;
}

message roas {
    // RPKI Route Origin Authorization
    uint32 v4_valid = 1;
    uint32 v4_invalid = 2;
    uint32 v4_unknown = 3;
    uint32 v6_valid = 4;
    uint32 v6_invalid = 5;
    uint32 v6_unknown = 6;
}
